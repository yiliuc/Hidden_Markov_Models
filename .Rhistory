# Non-stationary model
delta0 <- c(1, 1) / 2
mod2h <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, delta0, stationary = FALSE)
mod2s
set.seed(929)
# Parameters
n <- 10000
states <- 1:3
pi <- c(0.5, 0.3, 0.2)
A <- matrix(c(0.7, 0.2, 0.1,
0.3, 0.5, 0.2,
0.2, 0.3, 0.5), nrow = 3, byrow = TRUE)
mu <- c(0, 5, 10)
sigma <- c(1, 2, 3)
# Containers
Z <- numeric(n)              # hidden states
X <- numeric(n)              # observations
# Simulate first state and observation
Z[1] <- sample(states, 1, prob = pi)
X[1] <- rnorm(1, mean = mu[Z[1]], sd = sigma[Z[1]])
# Simulate the sequence
for (t in 2:n) {
Z[t] <- sample(states, 1, prob = A[Z[t - 1], ])
X[t] <- rnorm(1, mean = mu[Z[t]], sd = sigma[Z[t]])
}
# Combine into a data frame
hmm_data <- data.frame(time = 1:n, state = Z, observation = X)
m <- 3
# Initialize the transition probabilities
gamma0 <- matrix(c(0.8, 0.1, 0.1,
0.1, 0.8, 0.1,
0.1, 0.1, 0.8), nrow=nstates, byrow=TRUE)
m <- 3
# Initialize the transition probabilities
gamma0 <- matrix(c(0.8, 0.1, 0.1,
0.1, 0.8, 0.1,
0.1, 0.1, 0.8), nrow=3, byrow=TRUE)
# Initialize the initial distribution
delta0 <- rep(1/3, 3)
# Initial emission parameters
mu0 <- c(1, 2, 3)
sigma0 <- c(1, 1, 1)
x <- hmm_data[, 3]
# Stationary model
mod3s <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, stationary = TRUE)
mod3s
mod3h <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, delta0, stationary = FALSE)
mod3h
m <- 2
mu0 <- c(10, 20)             # Initial means
sigma0 <- c(2, 2)            # Initial standard deviations
gamma0 <- matrix(
c(0.9, 0.1,
0.1, 0.9),
m, m, byrow = TRUE
)
# Non-stationary model
delta0 <- c(1, 1) / 2
normal.HMM.pn2pw(m, mu0, sigma0, delta0,FALSE)
normal.HMM.pn2pw(m, mu0, sigma0, delta = delta0, stationary = FALSE)
normal.HMM.pn2pw(m, mu0, sigma0, gamma0, delta = delta0, stationary = FALSE)
p <- normal.HMM.pn2pw(m, mu0, sigma0, gamma0, delta = delta0, stationary = FALSE)
normal.HMM.pw2pn(m, p, FALSE)
pn <- normal.HMM.pw2pn(m, p, FALSE)
pn
pn$delta * dnorm(x[1], mean = pn$mu, sd = pn$sigma)
sumfoo <- sum(foo)
foo <- pn$delta * dnorm(x[1], mean = pn$mu, sd = pn$sigma)
foo <- foo / sumfoo
foo
foo <- pn$delta * dnorm(x[1], mean = pn$mu, sd = pn$sigma)
foo
sumfoo <- sum(foo)
sumfoo
pn <- normal.HMM.pw2pn(m, p, FALSE)
pn
foo <- pn$delta * dnorm(x[1], mean = pn$mu, sd = pn$sigma)
foo
sumfoo <- sum(foo)
sumfoo
foo <- foo / sumfoo
foo
P <- dnorm(x[2], mean = pn$mu, sd = pn$sigma)
P
foo <- foo %*% pn$gamma * P
foo
foo <- foo / sumfoo
foo
m <- 2
mu0 <- c(0, 7)             # Initial means
sigma0 <- c(2, 2)            # Initial standard deviations
gamma0 <- matrix(
c(0.9, 0.1,
0.1, 0.9),
m, m, byrow = TRUE
)
# Stationary model
mod2s <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, stationary = TRUE)
# Non-stationary model
delta0 <- c(1, 1) / 2
mod2h <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, delta0, stationary = FALSE)
mod2s
m <- 3
mu0 <- c(0, 5, 10)
sigma0 <- c(1.5, 2.5, 2)
gamma0 <- matrix(
c(0.8, 0.1, 0.1,
0.1, 0.8, 0.1,
0.1, 0.1, 0.8),
m, m, byrow = TRUE
)
# Stationary model
mod3s <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, stationary = TRUE)
# Non-stationary model
delta0 <- c(1, 1, 1) / 3
mod3h <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, delta0, stationary = FALSE)
mod3s
m <- 3
mu0 <- c(2, 3, 4)
sigma0 <- c(1.5, 2.5, 2)
gamma0 <- matrix(
c(0.8, 0.1, 0.1,
0.1, 0.8, 0.1,
0.1, 0.1, 0.8),
m, m, byrow = TRUE
)
# Stationary model
mod3s <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, stationary = TRUE)
# Non-stationary model
delta0 <- c(1, 1, 1) / 3
mod3h <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, delta0, stationary = FALSE)
mod3s
return(dxf)
normal.HMM.forecast <- function(xf, h = 1, x, mod) {
n    <- length(x)
nxf  <- length(xf)
dxf  <- matrix(0, nrow = h, ncol = nxf)
# Initial state probabilities after first observation
foo <- mod$delta * dnorm(x[1], mean = mod$mu, sd = mod$sigma)
sumfoo <- sum(foo)
lscale <- log(sumfoo)
foo <- foo / sumfoo
# Filtering through the observed sequence
for (i in 2:n) {
foo <- foo %*% mod$gamma * dnorm(x[i], mean = mod$mu, sd = mod$sigma)
sumfoo <- sum(foo)
lscale <- lscale + log(sumfoo)
foo <- foo / sumfoo
}
# Forecast h steps ahead
for (i in 1:h) {
foo <- foo %*% mod$gamma
for (j in 1:mod$m) {
dxf[i, ] <- dxf[i, ] + foo[j] * dnorm(xf, mean = mod$mu[j], sd = mod$sigma[j])
}
}
return(dxf)
}
h <- 1
xf <- 0:50
forecasts <- normal.HMM.forecast(xf, h, x, mod3s)
fc <- forecasts[1,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, #fc,
type = "h",
main = paste("Earthquake series: forecast distribution for", d[n] + 1),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
#=== Forecast 1 -4 steps ahead and plot these .
h <- 4
xf <- 0:45
forecasts <- pois.HMM.forecast(xf, h, x, mod3s)
#=== Forecast 1 -4 steps ahead and plot these .
h <- 4
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3s)
par(mfrow = c(2, 2), las = 1)
for (i in 1:4) {
fc <- forecasts[i,]
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + i),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
}
d <- dat[, 1]
x <- dat[, 2]
m <- 3
mu0 <- c(5, 15, 25)
sigma0 <- c(1.5, 2.5, 2)
gamma0 <- matrix(
c(0.8, 0.1, 0.1,
0.1, 0.8, 0.1,
0.1, 0.1, 0.8),
m, m, byrow = TRUE
)
# Stationary model
mod3s <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, stationary = TRUE)
# Non-stationary model
delta0 <- c(1, 1, 1) / 3
mod3h <- normal.HMM.mle(x, m, mu0, sigma0, gamma0, delta0, stationary = FALSE)
h <- 1
xf <- 0:50
forecasts <- normal.HMM.forecast(xf, h, x, mod3s)
fc <- forecasts[1,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, #fc,
type = "h",
main = paste("Earthquake series: forecast distribution for", d[n] + 1),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
h <- 4
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3s)
par(mfrow = c(2, 2), las = 1)
for (i in 1:4) {
fc <- forecasts[i,]
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + i),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
}
n <- length(x)
h <- 30
xf <- 0:45
forecasts <- pois.HMM.forecast(xf, h, x, mod3h)
h <- 30
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
lines(xf, dstat, col = "gray", lwd = 3)
h <- 50
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
lines(xf, dstat, col = "gray", lwd = 3)
m <- 3
lambda <- mod3h$lambda
delta <- solve(t(diag(m) - mod3h$gamma + 1), rep(1, m))
dstat <- numeric(length(xf))
for (j in 1:m) {
dstat <- dstat + delta[j] * dpois(xf, lambda[j])
}
h <- 30
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
h <- 50
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
m <- 3
mu <- mod3h$mu
sigma <- mod3h$sigma
# Stationary distribution
delta <- solve(t(diag(m) - mod3h$gamma + 1), rep(1, m))
# Mixture density over grid xf
dstat <- numeric(length(xf))
for (j in 1:m) {
dstat <- dstat + delta[j] * dnorm(xf, mean = mu[j], sd = sigma[j])
}
#=== Compare the 30 - year - ahead forecast with the long - term forecast .
h <- 30
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
lines(xf, dstat, col = "gray", lwd = 3)
h <- 50
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
lines(xf, dstat, col = "gray", lwd = 3)
h <- 10
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
lines(xf, dstat, col = "gray", lwd = 3)
h <- 2
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
lines(xf, dstat, col = "gray", lwd = 3)
h <- 1
xf <- 0:50
forecasts <- normal.HMM.forecast(xf, h, x, mod3s)
fc <- forecasts[1,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, #fc,
type = "h",
main = paste("Earthquake series: forecast distribution for", d[n] + 1),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
h <- 1
xf <- 0:45
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
lines(xf, dstat, col = "gray", lwd = 3)
h <- 30
xf <- 0:50
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
lines(xf, dstat, col = "gray", lwd = 3)
h <- 1
xf <- 0:50
forecasts <- normal.HMM.forecast(xf, h, x, mod3h)
fc <- forecasts[h,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, type = "h",
main = paste("Forecast distribution for", d[n] + h),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
lines(xf, dstat, col = "gray", lwd = 3)
h <- 1
xf <- 0:50
forecasts <- normal.HMM.forecast(xf, h, x, mod3s)
fc <- forecasts[1,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, #fc,
type = "h",
main = paste("Earthquake series: forecast distribution for", d[n] + 1),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
pois.HMM.pn2pw <- function(m, lambda, gamma, delta = NULL, stationary = TRUE) {
tlambda <- log(lambda)
if (m == 1) return(tlambda)
foo <- log(gamma / diag(gamma))
tgamma <- as.vector(foo[!diag(m)])
if (stationary) {
tdelta <- NULL
} else {
tdelta <- log(delta[-1] / delta[1])
}
parvect <- c(tlambda, tgamma, tdelta)
return(parvect)
}
pois.HMM.pw2pn <- function(m, parvect, stationary = TRUE) {
lambda <- exp(parvect[1:m])
gamma <- diag(m)
if (m == 1) {
return(list(lambda = lambda, gamma = gamma, delta = 1))
}
gamma[!gamma] <- exp(parvect[(m + 1):(m * m)])
gamma <- gamma / apply(gamma, 1, sum)
if (stationary) {
delta <- solve(t(diag(m) - gamma + 1), rep(1, m))
} else {
foo <- c(1, exp(parvect[(m * m + 1):(m * m + m - 1)]))
delta <- foo / sum(foo)
}
return(list(lambda = lambda, gamma = gamma, delta = delta))
}
pois.HMM.mllk <- function(parvect, x, m, stationary = TRUE, ...) {
if (m == 1) return(-sum(dpois(x, exp(parvect), log = TRUE)))
n <- length(x)
pn <- pois.HMM.pw2pn(m, parvect, stationary = stationary)
foo <- pn$delta * dpois(x[1], pn$lambda)
sumfoo <- sum(foo)
lscale <- log(sumfoo)
foo <- foo / sumfoo
for (i in 2:n) {
if (!is.na(x[i])) {
P <- dpois(x[i], pn$lambda)
} else {
P <- rep(1, m)
}
foo <- foo %*% pn$gamma * P
sumfoo <- sum(foo)
lscale <- lscale + log(sumfoo)
foo <- foo / sumfoo
}
mllk <- -lscale
return(mllk)
}
pois.HMM.mle <- function(x, m, lambda0, gamma0, delta0 = NULL, stationary = TRUE, ...) {
parvect0 <- pois.HMM.pn2pw(m, lambda0, gamma0, delta0, stationary = stationary)
mod <- nlm(pois.HMM.mllk, parvect0, x = x, m = m, stationary = stationary)
pn <- pois.HMM.pw2pn(m = m, mod$estimate, stationary = stationary)
mllk <- mod$minimum
np <- length(parvect0)
AIC <- 2 * (mllk + np)
n <- sum(!is.na(x))
BIC <- 2 * mllk + np * log(n)
list(
m = m,
lambda = pn$lambda,
gamma = pn$gamma,
delta = pn$delta,
code = mod$code,
mllk = mllk,
AIC = AIC,
BIC = BIC
)
}
pois.HMM.forecast <- function(xf, h = 1, x, mod)
{
n    <- length(x)
nxf  <- length(xf)
dxf  <- matrix(0, nrow = h, ncol = nxf)
foo  <- mod$delta * dpois(x[1], mod$lambda)
sumfoo <- sum(foo)
lscale <- log(sumfoo)
foo <- foo / sumfoo
for (i in 2:n)
{
foo <- foo %*% mod$gamma * dpois(x[i], mod$lambda)
sumfoo <- sum(foo)
lscale <- lscale + log(sumfoo)
foo <- foo / sumfoo
}
for (i in 1:h)
{
foo <- foo %*% mod$gamma
for (j in 1:mod$m)
dxf[i, ] <- dxf[i, ] + foo[j] * dpois(xf, mod$lambda[j])
}
return(dxf)
}
################################################################################
# Read earthquake data
dat <- read.table("http://www.hmms-for-time-series.de/second/data/earthquakes.txt")
# Or set your own path
x <- dat[, 2]
d <- dat[, 1]
n <- length(x)
# ============================ fit 2-state HMM ============================
m <- 2
lambda0 <- c(15, 25) # intial parameters
gamma0 <- matrix(
c(0.9, 0.1,
0.1, 0.9),
m, m, byrow = TRUE
)
mod2s <- pois.HMM.mle(x, m, lambda0, gamma0, stationary = TRUE)
delta0 <- c(1, 1) / 2 # Initial distribution
mod2h <- pois.HMM.mle(x, m, lambda0, gamma0, delta = delta0, stationary = FALSE)
mod2s
mod2h
# ============================ fit 3-state HMM ============================
m <- 3
lambda0 <- c(10, 20, 30)
gamma0 <- matrix(
c(0.8, 0.1, 0.1,
0.1, 0.8, 0.1,
0.1, 0.1, 0.8),
m, m, byrow = TRUE
)
mod3s <- pois.HMM.mle(x, m, lambda0, gamma0, stationary = TRUE)
delta0 <- c(1, 1, 1) / 3
mod3h <- pois.HMM.mle(x, m, lambda0, gamma0, delta = delta0, stationary = FALSE)
mod3s
mod3h
################################################################################
#=== Use it for 1 - step - ahead and plot the forecast d i s t r i b u t i o n .
h <- 1
xf <- 0:50
forecasts <- pois.HMM.forecast(xf, h, x, mod3s)
fc <- forecasts[1,]
par(mfrow = c(1, 1), las = 1)
plot(xf, fc, #fc,
type = "h",
main = paste("Earthquake series: forecast distribution for", d[n] + 1),
xlim = c(0, max(xf)), ylim = c(0, 0.12),
xlab = "count", ylab = "probability", lwd = 3)
